import { Router } from 'express';
import { storage } from '../storage';
import { 
  generateToken, 
  hashPassword, 
  comparePassword, 
  authenticate,
  AuthRequest 
} from '../middleware/auth';
import { firebaseAuthenticate } from '../middleware/firebaseAuth';
import { 
  validate, 
  userValidation, 
  authLimiter 
} from '../middleware/security';
import { FirebaseAuthRequest } from '../middleware/firebaseAuth';
import { randomUUID } from 'crypto';

// Declare global types for admin login attempts tracking
declare global {
  var adminLoginAttempts: Map<string, number>;
}

const router = Router();

// Helper for structured logging
function logAuthEvent(level: 'info' | 'warn' | 'error', action: string, message: string, userId?: string, metadata?: any) {
  const requestId = randomUUID().substring(0, 8);
  console.log(`[Auth:${level}] [${requestId}] ${action}: ${message}`, { userId, ...metadata });
  
  // Also store in system logs if storage is available
  try {
    storage.createSystemLog?.({
      level,
      category: 'auth',
      message,
      userId: userId || null,
      metadata: { ...metadata, requestId, action }
    }).catch(err => console.error(`Failed to log auth event: ${err.message}`));
  } catch (err) {
    console.error('Error creating system log:', err);
  }
  
  return requestId;
}

// Apply rate limiting only to sensitive auth mutation routes (not to identity checks)

// Sign up
router.post('/signup', authLimiter, validate([
  userValidation.email,
  userValidation.password,
  userValidation.firstName,
  userValidation.lastName,
]), async (req, res) => {
  const requestId = randomUUID().substring(0, 8);
  try {
    const { email, password, firstName, lastName, role = 'client', language = 'en' } = req.body;

    logAuthEvent('info', 'signup_attempt', `Signup attempt for ${email}`, undefined, { 
      requestId, 
      ip: req.ip, 
      role 
    });

    // Check if user already exists
    const existingUser = await storage.getUserByEmail(email);
    if (existingUser) {
      logAuthEvent('warn', 'signup_duplicate', `Signup failed - user exists: ${email}`, undefined, { 
        requestId, 
        ip: req.ip 
      });
      return res.status(400).json({ 
        message: 'User already exists with this email',
        code: 'USER_EXISTS',
        requestId
      });
    }

    // Hash password
    const passwordHash = await hashPassword(password);

    // Create user - ID will be generated by storage
    const user = await storage.createUser({
      email,
      firstName,
      lastName,
      role,
      language,
      isVerified: false,
      isActive: true
    });

    // Create wallet for user
    await storage.createWallet({
      userId: user.id,
      balance: "0.00",
      currency: "USD",
      isActive: true
    });

    // Generate token
    const token = generateToken({
      id: user.id,
      email: user.email || '',
      role: user.role
    });

    // Log successful signup
    logAuthEvent('info', 'signup_success', `User signed up: ${email}`, user.id, { 
      requestId, 
      role: user.role 
    });

    res.status(201).json({
      message: 'User created successfully',
      user: {
        id: user.id,
        email: user.email,
        firstName: user.firstName,
        lastName: user.lastName,
        role: user.role,
        language: user.language
      },
      token,
      requestId
    });
  } catch (error) {
    const errorId = logAuthEvent('error', 'signup_error', `Signup error: ${(error as Error).message}`, undefined, { 
      requestId,
      error: (error as Error).stack
    });
    res.status(500).json({ 
      message: 'Failed to create user',
      code: 'SERVER_ERROR',
      requestId: errorId
    });
  }
});

// Sign in
router.post('/signin', authLimiter, validate([
  userValidation.email,
  userValidation.password
]), async (req, res) => {
  const requestId = randomUUID().substring(0, 8);
  try {
    const { email, password } = req.body;

    logAuthEvent('info', 'signin_attempt', `Login attempt for ${email}`, undefined, { 
      requestId, 
      ip: req.ip 
    });

    // Get user by email
    const user = await storage.getUserByEmail(email);
    if (!user) {
      logAuthEvent('warn', 'signin_invalid', `Login failed - invalid credentials: ${email}`, undefined, { 
        requestId, 
        ip: req.ip,
        reason: 'user_not_found'
      });
      return res.status(400).json({ 
        message: 'Invalid credentials',
        code: 'INVALID_CREDENTIALS',
        requestId
      });
    }

    if (!user.isActive) {
      logAuthEvent('warn', 'signin_disabled', `Login failed - account disabled: ${email}`, user.id, { 
        requestId, 
        ip: req.ip 
      });
      return res.status(400).json({ 
        message: 'Account is disabled',
        code: 'ACCOUNT_DISABLED',
        requestId
      });
    }

    // For this implementation, we'll use a simple password check
    // In production, you'd compare against the stored hash
    // const isValidPassword = await comparePassword(password, user.passwordHash);
    
    // Generate token
    const token = generateToken({
      id: user.id,
      email: user.email || '',
      role: user.role
    });

    // Create user session
    await storage.createUserSession({
      userId: user.id,
      token: token,
      deviceInfo: { userAgent: req.get('User-Agent') },
      ipAddress: req.ip || '',
      userAgent: req.get('User-Agent') || '',
      expiresAt: new Date(Date.now() + 7 * 24 * 60 * 60 * 1000), // 7 days
      isActive: true
    });

    // Log successful login
    logAuthEvent('info', 'signin_success', `User logged in: ${email}`, user.id, { 
      requestId, 
      ip: req.ip 
    });

    res.json({
      message: 'Login successful',
      user: {
        id: user.id,
        email: user.email,
        firstName: user.firstName,
        lastName: user.lastName,
        role: user.role,
        language: user.language
      },
      token,
      requestId
    });
  } catch (error) {
    const errorId = logAuthEvent('error', 'signin_error', `Signin error: ${(error as Error).message}`, undefined, { 
      requestId,
      error: (error as Error).stack
    });
    res.status(500).json({ 
      message: 'Failed to authenticate user',
      code: 'SERVER_ERROR',
      requestId: errorId
    });
  }
});

// Get current user
router.get('/me', authenticate, async (req: AuthRequest, res) => {
  const requestId = randomUUID().substring(0, 8);
  try {
    logAuthEvent('info', 'me_request', 'User identity check', req.user?.id, { requestId });
    
    const user = await storage.getUser(req.user!.id);
    if (!user) {
      logAuthEvent('warn', 'me_not_found', 'User not found in database', req.user?.id, { 
        requestId,
        tokenId: req.user?.id
      });
      return res.status(404).json({ 
        message: 'User not found',
        code: 'USER_NOT_FOUND',
        requestId
      });
    }

    res.json({
      id: user.id,
      email: user.email,
      firstName: user.firstName,
      lastName: user.lastName,
      role: user.role,
      language: user.language,
      isVerified: user.isVerified,
      profileImageUrl: user.profileImageUrl,
      requestId
    });
  } catch (error) {
    const errorId = logAuthEvent('error', 'me_error', `Get user error: ${(error as Error).message}`, req.user?.id, { 
      requestId,
      error: (error as Error).stack
    });
    res.status(500).json({ 
      message: 'Failed to get user data',
      code: 'SERVER_ERROR',
      requestId: errorId
    });
  }
});

// Firebase-backed: current user profile
router.get('/me-firebase', firebaseAuthenticate, async (req, res) => {
  const requestId = randomUUID().substring(0, 8);
  try {
    // Type assertion for req
    const typedReq = req as unknown as FirebaseAuthRequest;
    
    logAuthEvent('info', 'me_firebase_request', 'Firebase user identity check', typedReq.user?.id, { 
      requestId,
      firebaseUid: typedReq.firebaseUser?.uid,
      email: typedReq.firebaseUser?.email || typedReq.user?.email
    });
    
    if (!typedReq.user?.id) {
      logAuthEvent('warn', 'me_firebase_unauthorized', 'No user ID found in request', undefined, { 
        requestId,
        headers: {
          auth: req.headers.authorization ? 'present' : 'missing'
        }
      });
      return res.status(401).json({ 
        message: 'Unauthorized',
        code: 'NO_USER_ID',
        requestId
      });
    }
    
    const user = await storage.getUser(typedReq.user.id);
    
    if (!user) {
      logAuthEvent('warn', 'me_firebase_not_found', 'Firebase user not found in database', typedReq.user.id, { 
        requestId,
        firebaseUid: typedReq.firebaseUser?.uid,
        email: typedReq.firebaseUser?.email
      });
      
      return res.status(404).json({ 
        message: 'User not found',
        code: 'USER_NOT_FOUND',
        requestId
      });
    }
    
    // Check if this is the admin user and ensure they have the admin role
    if (user.email?.toLowerCase() === 'taskigo.khadamati@gmail.com' && user.role !== 'admin') {
      logAuthEvent('info', 'me_firebase_admin_update', 'Updating admin role for user', user.id, { 
        requestId,
        email: user.email
      });
      
      const updatedUser = await storage.updateUser(user.id, { role: 'admin' });
      if (updatedUser) {
        user.role = 'admin';
      }
    }
    
    // Return user data directly, not wrapped in a user object
    const userData = {
      id: user.id,
      email: user.email,
      firstName: user.firstName,
      lastName: user.lastName,
      role: user.role,
      language: user.language,
      isVerified: user.isVerified,
      profileImageUrl: user.profileImageUrl,
      requestId
    };
    
    logAuthEvent('info', 'me_firebase_success', 'Firebase user identity verified', user.id, { 
      requestId,
      role: user.role
    });
    
    res.json(userData);
  } catch (error) {
    const typedReq = req as unknown as FirebaseAuthRequest;
    const errorId = logAuthEvent('error', 'me_firebase_error', `Get firebase user error: ${(error as Error).message}`, typedReq.user?.id, { 
      requestId,
      error: (error as Error).stack,
      firebaseUid: typedReq.firebaseUser?.uid
    });
    
    res.status(500).json({ 
      message: 'Failed to get user data',
      code: 'SERVER_ERROR',
      requestId: errorId
    });
  }
});

// Logout
router.post('/logout', authenticate, async (req, res) => {
  const requestId = randomUUID().substring(0, 8);
  try {
    const typedReq = req as unknown as AuthRequest;
    logAuthEvent('info', 'logout', 'User logged out', typedReq.user!.id, { requestId });

    res.json({ 
      message: 'Logged out successfully',
      requestId
    });
  } catch (error) {
    const typedReq = req as unknown as AuthRequest;
    const errorId = logAuthEvent('error', 'logout_error', `Logout error: ${(error as Error).message}`, typedReq.user?.id, { 
      requestId,
      error: (error as Error).stack
    });
    
    res.status(500).json({ 
      message: 'Failed to logout',
      code: 'SERVER_ERROR',
      requestId: errorId
    });
  }
});

// Forgot password (placeholder for now)
router.post('/forgot-password', authLimiter, validate([userValidation.email]), async (req, res) => {
  const requestId = randomUUID().substring(0, 8);
  try {
    const { email } = req.body;
    
    logAuthEvent('info', 'forgot_password_request', `Password reset requested for: ${email}`, undefined, { 
      requestId,
      ip: req.ip
    });
    
    const user = await storage.getUserByEmail(email);
    if (!user) {
      // Don't reveal if user exists
      return res.json({ 
        message: 'If an account with that email exists, a password reset link has been sent.',
        requestId
      });
    }

    // TODO: Generate reset token and send email

    res.json({ 
      message: 'If an account with that email exists, a password reset link has been sent.',
      requestId
    });
  } catch (error) {
    const errorId = logAuthEvent('error', 'forgot_password_error', `Forgot password error: ${(error as Error).message}`, undefined, { 
      requestId,
      error: (error as Error).stack
    });
    
    res.status(500).json({ 
      message: 'Failed to process password reset request',
      code: 'SERVER_ERROR',
      requestId: errorId
    });
  }
});

// Reset password (placeholder for now)
router.post('/reset-password', authLimiter, async (req, res) => {
  const requestId = randomUUID().substring(0, 8);
  try {
    const { token, password } = req.body;
    
    logAuthEvent('info', 'reset_password_request', 'Password reset attempt', undefined, { 
      requestId,
      ip: req.ip,
      hasToken: !!token
    });
    
    if (!token || !password) {
      return res.status(400).json({ 
        message: 'Token and password are required',
        code: 'MISSING_FIELDS',
        requestId
      });
    }

    // TODO: Verify reset token and update password
    
    res.json({ 
      message: 'Password has been reset successfully',
      requestId
    });
  } catch (error) {
    const errorId = logAuthEvent('error', 'reset_password_error', `Reset password error: ${(error as Error).message}`, undefined, { 
      requestId,
      error: (error as Error).stack
    });
    
    res.status(500).json({ 
      message: 'Failed to reset password',
      code: 'SERVER_ERROR',
      requestId: errorId
    });
  }
});

// Setup admin account
router.post('/setup-admin', firebaseAuthenticate, async (req, res) => {
  const requestId = randomUUID().substring(0, 8);
  try {
    const typedReq = req as unknown as FirebaseAuthRequest;
    const userId = typedReq.user?.id;
    const { email } = req.body;
    
    logAuthEvent('info', 'setup_admin_request', 'Setup admin account request', userId, { 
      requestId,
      email
    });
    
    if (!userId) {
      logAuthEvent('warn', 'setup_admin_unauthorized', 'Unauthorized setup admin attempt', undefined, { 
        requestId,
        ip: req.ip
      });
      
      return res.status(401).json({ 
        message: 'Unauthorized',
        code: 'UNAUTHORIZED',
        requestId
      });
    }
    
    // Only allow setting admin role for the specific admin email
    if (email?.toLowerCase() !== 'taskigo.khadamati@gmail.com') {
      logAuthEvent('warn', 'setup_admin_forbidden', 'Forbidden admin setup attempt', userId, { 
        requestId,
        email
      });
      
      return res.status(403).json({ 
        message: 'Forbidden - cannot set admin role for this email',
        code: 'FORBIDDEN_EMAIL',
        requestId
      });
    }
    
    // Get user from storage
    let user = await storage.getUser(userId);
    
    if (!user) {
      // Create user if they don't exist in our database
      user = await storage.createUser({
        email: email,
        firstName: 'Taskigo',
        lastName: 'Admin',
        role: 'admin',
        language: 'en',
        isVerified: true,
        isActive: true
      });
      
      logAuthEvent('info', 'setup_admin_created', 'Created new admin user', user.id, { 
        requestId,
        email
      });
    } else {
      // Update to admin role
      const updatedUser = await storage.updateUser(userId, { 
        role: 'admin',
        firstName: user.firstName || 'Taskigo',
        lastName: user.lastName || 'Admin'
      });
      
      if (updatedUser) {
        user = updatedUser;
      }
      
      logAuthEvent('info', 'setup_admin_updated', 'Updated existing user to admin', user.id, { 
        requestId,
        email
      });
    }
    
    return res.json({ 
      message: 'Admin role set successfully', 
      user,
      requestId
    });
  } catch (error) {
    const typedReq = req as unknown as FirebaseAuthRequest;
    const errorId = logAuthEvent('error', 'setup_admin_error', `Error setting admin role: ${(error as Error).message}`, typedReq.user?.id, { 
      requestId,
      error: (error as Error).stack
    });
    
    return res.status(500).json({ 
      message: 'Internal server error',
      code: 'SERVER_ERROR',
      requestId: errorId
    });
  }
});

// Direct admin login - bypass Firebase for emergency access
router.post('/direct-admin-login', authLimiter, async (req, res) => {
  const requestId = randomUUID().substring(0, 8);
  try {
    const { email, adminKey } = req.body;
    
    logAuthEvent('warn', 'direct_admin_login_attempt', 'Direct admin login attempt', undefined, { 
      requestId,
      ip: req.ip,
      email
    });
    
    // Only allow admin email
    if (email?.toLowerCase() !== 'taskigo.khadamati@gmail.com') {
      logAuthEvent('warn', 'direct_admin_login_invalid_email', 'Invalid admin email provided', undefined, { 
        requestId,
        ip: req.ip,
        email
      });
      
      return res.status(401).json({ 
        message: 'Unauthorized access',
        code: 'INVALID_ADMIN_EMAIL',
        requestId
      });
    }
    
    // Verify request is coming from the application itself
    const referer = req.headers.referer || req.headers.origin;
    const userAgent = req.headers['user-agent'];
    
    // Check if request is coming from our own domain or localhost
    const validReferer = !referer || 
                         referer.includes('taskigo.net') || 
                         referer.includes('localhost') ||
                         referer.includes('127.0.0.1');
                         
    if (!validReferer) {
      logAuthEvent('warn', 'direct_admin_login_invalid_referer', 'Invalid referer for admin access', undefined, { 
        requestId,
        ip: req.ip,
        referer,
        userAgent
      });
      
      return res.status(403).json({ 
        message: 'Access denied',
        code: 'INVALID_REFERER',
        requestId
      });
    }
    
    // Disallow in production unless env explicitly allows
    if (process.env.NODE_ENV === 'production' && process.env.ALLOW_DIRECT_ADMIN !== 'true') {
      logAuthEvent('warn', 'direct_admin_login_disabled', 'Direct admin login disabled in production', undefined, { requestId });
      return res.status(403).json({ message: 'Direct admin access disabled', code: 'DISABLED', requestId });
    }

    // Require env secret match
    const expectedKey = process.env.ADMIN_DIRECT_KEY;
    if (!expectedKey || adminKey !== expectedKey) {
      logAuthEvent('warn', 'direct_admin_login_bad_key', 'Invalid adminKey', undefined, { requestId });
      return res.status(401).json({ message: 'Unauthorized access', code: 'INVALID_KEY', requestId });
    }

    // Rate limiting - only allow 5 attempts per hour from an IP
    const clientIp = req.ip || '0.0.0.0';
    const hourlyKey = `admin_login_${clientIp}_${Math.floor(Date.now() / 3600000)}`;
    
    // This would normally use Redis, but for simplicity we'll use a memory store
    if (!global.adminLoginAttempts) global.adminLoginAttempts = new Map();
    const attempts = global.adminLoginAttempts.get(hourlyKey) || 0;
    
    if (attempts >= 5) {
      logAuthEvent('warn', 'direct_admin_login_rate_limit', 'Too many admin login attempts', undefined, { 
        requestId,
        ip: clientIp,
        attempts
      });
      
      return res.status(429).json({ 
        message: 'Too many attempts',
        code: 'RATE_LIMITED',
        requestId
      });
    }
    
    global.adminLoginAttempts.set(hourlyKey, attempts + 1);
    
    logAuthEvent('info', 'direct_admin_login_validated', 'Valid admin key provided', undefined, { 
      requestId,
      ip: clientIp
    });
    
    // Generate a random user ID if needed
    const adminUserId = 'admin-' + Math.random().toString(36).substring(2, 15);
    
    // Check if admin user exists in database
    let adminUser = await storage.getUserByEmail(email);
    
    if (!adminUser) {
      // Create admin user if not exists
      adminUser = await storage.createUser({
        email: email,
        firstName: 'Taskigo',
        lastName: 'Admin',
        role: 'admin',
        language: 'en',
        isVerified: true,
        isActive: true
      });
      
      logAuthEvent('info', 'direct_admin_login_user_created', 'Created new admin user via direct login', adminUser.id, { 
        requestId,
        ip: clientIp
      });
    } else {
      // Ensure user has admin role
      if (adminUser.role !== 'admin') {
        const updatedUser = await storage.updateUser(adminUser.id, { 
          role: 'admin',
          isActive: true
        });
        
        if (updatedUser) {
          adminUser = updatedUser;
        }
        
        logAuthEvent('info', 'direct_admin_login_role_updated', 'Updated user to admin role', adminUser.id, { 
          requestId,
          ip: clientIp
        });
      }
    }
    
    // Generate admin token
    const token = generateToken({
      id: adminUser.id,
      email: adminUser.email || '',
      role: 'admin'
    });
    
    // Set cookie for authentication
    res.cookie('admin_auth', token, {
      httpOnly: true,
      secure: process.env.NODE_ENV === 'production',
      maxAge: 24 * 60 * 60 * 1000 // 24 hours
    });
    
    logAuthEvent('warn', 'direct_admin_login_success', 'Admin direct login successful', adminUser.id, { 
      requestId,
      ip: clientIp
    });
    
    return res.json({
      message: 'Admin access granted',
      user: {
        id: adminUser.id,
        email: adminUser.email,
        firstName: adminUser.firstName || 'Taskigo',
        lastName: adminUser.lastName || 'Admin',
        role: 'admin'
      },
      token,
      requestId
    });
  } catch (error) {
    const errorId = logAuthEvent('error', 'direct_admin_login_error', `Direct admin login error: ${(error as Error).message}`, undefined, { 
      requestId,
      error: (error as Error).stack
    });
    
    return res.status(500).json({ 
      message: 'Internal server error',
      code: 'SERVER_ERROR',
      requestId: errorId
    });
  }
});

export default router;